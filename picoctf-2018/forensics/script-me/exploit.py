from pwn import *
import string
import re


SPLIT_KEY = "||"

def get_data_from_file():
    with open('combinations.txt') as f:
        data = f.read().strip().split('\n')

    data = filter(None, data)

    d = {}
    for line in data:
        line = line.split(SPLIT_KEY)
        question = line[0]
        answer = line[1]
        d[question] = answer
    return d

def load_table():
    with open('lookup.data') as f:
        table = f.readlines()

    data = dict()

    table = map(string.strip, table)
    table = filter(None, table)
    for entry in table:
        entry = entry.split("||")
        value = entry[-1]

        key = entry[0].split("=")[0].strip()
        # entry = map(string.strip, entry)

        # if entry[0] not in data:
            # data[entry[0]] = {}
        data[key] = value

    return data

def explode(s):
    regex = r"^\((.+?)\)$"
    m = re.match(regex, s)

    if not m:
        return "" # no matches

    return m.group(1)

def get_split(p, start=False):
    num_open = 1
    if start:
        idx = 0
    else:
        idx = 1
    while(num_open):
        idx += 1
        # print idx
        tmp = p[idx] if start else p[-idx]
        if (tmp == ")" and start) or (tmp == "(" and not start):
            num_open -= 1
        else:
            num_open += 1

    # return idx+1 if start else -idx
    idx = idx+1 if start else -idx

    # return p_start, p_end
    return (p[:idx], p[idx:])

def combine(p1,p2, lp1, lp2):
    # () + () = ()()                                      => [combine]
    # ((())) + () = ((())())                              => [absorb-right]
    # () + ((())) = (()(()))                              => [absorb-left]

    # (())(()) + (())(()) = (())(()())(())

    # (())(()) + () = (())(()())                          => [combined-absorb-right]
    # () + (())(()) = (()())(())                          => [combined-absorb-left]

    # (())(()) + ( (()) ) = ( (())(()) (()) )                  => [absorb-combined-right]
    # ( (()) ) + (())(()) = ( (()) (())(()) )                   => [absorb-combined-left]

    # () + (()) + ((())) = (()()) + ((())) = ((()())(())) => [left-associative]

    # Example:
    # (()) + () = () + (()) = (()())

    # Let's start with a warmup.
    # ()()() + (()()()) = ???

    # combine
    if p1 == "()" and p2 == "()":
        return p1 + p2

    # absorb-right
    # combined-absorb-right
    if p2 == "()":
        return "({}{})".format(explode(p1), p2)

    # absorb-left
    # combined-absorb-left
    if p1 == "()":
        return "({}{})".format(p1, explode(p2))

    # (())(()) + ( (()) ) = ( (())(()) (()) )                  => [absorb-combined-right]
    # ( (()) ) + (())(()) = ( (()) (())(()) )                  => [absorb-combined-left]

    # absorb combined right
    if lp1 == len(p1):
        pass

    # absorb combined left
    if lp2 == len(p2):
        pass

    # print "combine"
    return "({}{})".format(explode(p1), explode(p2))

def can_explode(p):
    exploded = explode(p)

    if (not exploded
        or exploded[0] != '('
        or exploded[-1] != ')'):
        return False

    p_s, p_e = get_split(p)

    return p_e == p

def is_squigly_one(p):
    exploded = explode(p)

    if not exploded: # ()
        return False

    trunc = exploded.replace('()','')
    return trunc == ''

def is_squigly_combination(p, friendly=False):
    check = " "
    while(p):
        (p_s, p_e) = get_split(p)

        if friendly:
            if not is_squigly_one(p_e) and not is_empty_squigly(p_e):
                print p_e
                return False
        else:
            if not is_squigly_one(p_e):
                return False

        p = p_s
    return True

def is_combination(p):
    (p_s, p_e) = get_split(p)
    return p_e != p

def is_empty_squigly(p):
    return p.replace('()', '') == ''

def flip(p):
    return "".join([")" if l == "(" else "(" for l in p])

"""
() + () = ()()                                      => [combine]
((())) + () = ((())())                              => [absorb-right]
() + ((())) = (()(()))                              => [absorb-left]
(())(()) + () = (())(()())                          => [combined-absorb-right]
() + (())(()) = (()())(())                          => [combined-absorb-left]
(())(()) + ((())) = ((())(())(()))                  => [absorb-combined-right]
((())) + (())(()) = ((())(())(()))                  => [absorb-combined-left]
() + (()) + ((())) = (()()) + ((())) = ((()())(())) => [left-associative]
"""

# >  ((()()()()()())(()())()(())) ( ((()())()())() )
# Failed: (()()()()()()) + (()()) + (()(())) + (((()())()())())
#      ( ((()()()()()())(()())()(()))  ((()())()())())
#r:      ((()()()()()())(()())()(())) (((()())()())())

def get_deepness_level(p):
    num_open = 0
    highest = 0
    idx = 0
    while(idx < len(p)):
        if p[idx] == "(":
            num_open += 1
        else:
            num_open -= 1

        if num_open > highest:
            highest = num_open

        idx += 1

    return highest


def get_deepness_levels(p1, p2):
    return (get_deepness_level(p1), get_deepness_level(p2))

"""
() + () = ()()                                      => [combine]
((())) + () = ((())())                              => [absorb-right]
() + ((())) = (()(()))                              => [absorb-left]
(())(()) + () = (())(()())                          => [combined-absorb-right]
() + (())(()) = (()())(())                          => [combined-absorb-left]
(())(()) + ((())) = ((())(())(()))                  => [absorb-combined-right]
((())) + (())(()) = ((())(())(()))                  => [absorb-combined-left]
() + (()) + ((())) = (()()) + ((())) = ((()())(())) => [left-associative]
"""

def deepness_solver(p1,p2):
    p1_s, p1_tmp = get_split(p1)
    p2_tmp, p2_end = get_split(p2, start=True)

    p1_deep, p2_deep = get_deepness_levels(p1,p2)
    p1_tmp_deep, p2_tmp_deep = get_deepness_levels(p1_tmp, p2_tmp)

    if p1_deep == p2_deep:
        return "{}{}".format(p1, p2)

    if p1_deep > p2_deep:
        return "({}{})".format(explode(p1), p2)

    # if p1_deep < p2_deep:
    return "({}{})".format(p1,explode(p2))


def typed_solver(p1,p2):
    print "> ", p1, p2
    p1_ce = can_explode(p1)
    p2_ce = can_explode(p2)
    p1_is_squig = is_squigly_one(p1)
    p2_is_squig = is_squigly_one(p2)
    p1_s, p1_tmp = get_split(p1)
    p2_tmp, p2_end = get_split(p2, start=True)
    p1_empty_squig = is_empty_squigly(p1)
    p2_empty_squig = is_empty_squigly(p2)

    # type 1
    if is_empty_squigly(p1):
        # type 1
        if is_empty_squigly(p2):
            return "{}{}".format(p1,p2)

        # type 2
        if is_squigly_one(p2):
            return "({}{})".format(p1,explode(p2))

        # type 3
        if not is_combination(p2):
            return "({}{})".format(p1,explode(p2))

        if is_combination(p2):
            return "{}{}".format(solve(p1,p2_tmp), p2_end)

    # type 2
    if is_squigly_one(p1):
        if is_empty_squigly(p2):
            return "({}{})".format(explode(p1),p2)

        if is_squigly_one(p2):
            return "{}{}".format(p1,p2)

        if not is_combination(p2):
            return "({}{})".format(p1,explode(p2))

        if is_combination(p2):
            return "{}{}".format(solve(p1,p2_tmp), p2_end)

    # type 3
    if not is_combination(p1):
        if is_empty_squigly(p2):
            return "({}{})".format(explode(p1),p2)

        if is_squigly_one(p2):
            return "({}{})".format(explode(p1),p2)

        if not is_combination(p2):
            p1_deep, p2_deep = get_deepness_levels(p1,p2)

            if p1_deep == p2_deep:
                return "{}{}".format(p1,p2)

            if p1_deep > p2_deep:
                return "({}{})".format(explode(p1), p2)
            else:
                return "({}{})".format(p1, explode(p2))

            # print "here", p1, p2
            if is_combination(explode(p1)) and is_combination(explode(p2)):
                return "({}{})".format(p1, explode(p2))

            return "{}{}".format(p1,p2)

        if is_combination(p2):
            return "({}{})".format(explode(p1),p2)

# (((()) ) (()()()(())()())

# >  (()(((()()())()())()())(()()()))
# >  (()(((()()())()())()())(()()())) (()(((()()())()())()()))
# >  (()(((()()())()())()())(()()()))(()(((()()())()())()())) (()(((()()())()())()()))
# >  (()(((()()())()())()())(()()()))(()(((()()())()())()())(()(((()()())()())()()))) (()()()(())()())
# Fail: (()(((()()())()())()())) + (()()()) + (()(((()()())()())()())) + (()(((()()())()())()())) + (()()()(())()())
# Answ: (()(((()()())()())()())(()()()))(()(((()()())()())()())) (()(((()()())()())()())(()()()(())()()) )
# ----: (()(((()()())()())()())(()()()))(()(((()()())()())()())  (()(((()()())()())()()))(()()()(())()()) )

    # type 4
    if is_combination(p1):
        if is_empty_squigly(p2):
            return "{}{}".format(p1_s, solve(p1_tmp, p2))

        if is_squigly_one(p2):
            return "{}{}".format(p1_s, solve(p1_tmp, p2))

        if not is_combination(p2):
            if not is_combination(explode(p2)):
                return "({}{})".format(p1, explode(p2))
            else:
                p1_deep, p2_deep = get_deepness_levels(p1_tmp,p2)

                if p1_deep == p2_deep:
                    return "{}{}".format(p1,p2)

                if p1_deep > p2_deep:
                    return "{}({}{})".format(p1_s, explode(p1_tmp), p2)
                else:
                    return "({}{})".format(p1, explode(p2))

                if is_squigly_one(p1_tmp):
                    return "({}{})".format(p1, explode(p2))

                if not is_combination(explode(p1_tmp)):
                    return "({}{})".format(p1, explode(p2))

                if is_combination(explode(p1_tmp)) and is_combination(explode(p2_tmp)):
                    return "{}({}{})".format(p1_s, explode(p1_tmp), p2)

                return "{}{}".format(p1_s, solve(p1_tmp, p2))

        if is_combination(p2):
            p1_deep, p2_deep = get_deepness_levels(p1_tmp,p2_tmp)

            if p1_deep == p2_deep:
                return "{}({}{}){}".format(p1_s, explode(p1_tmp), explode(p2_tmp), p2_end)

            if p1_deep > p2_deep:
                return "{}({}{}){}".format(p1_s, explode(p1_tmp), p2_tmp, p2_end)
            else:
                return "{}({}{}){}".format(p1_s, p1_tmp, explode(p2_tmp), p2_end)

    return "123"

def final_solve(p1, p2):
    p1_ce = can_explode(p1)
    p2_ce = can_explode(p2)
    p1_is_squig = is_squigly_one(p1)
    p2_is_squig = is_squigly_one(p2)
    p1_s, p1_tmp = get_split(p1)
    p2_tmp, p2_end = get_split(p2, start=True)
    p1_empty_squig = is_empty_squigly(p1)
    p2_empty_squig = is_empty_squigly(p2)

    if (p1_empty_squig and p2_empty_squig) or (p1_is_squig and p2_is_squig) or (is_squigly_one(p1_tmp) and is_squigly_one(p2_tmp)):
        # () + () = ()() => [combine]
        print "> simple combine", p1, p2
        return "{}{}".format(p1,p2)

    if can_explode(p1_tmp):
        if p2_is_squig:
            print ">  combine-absorb right", p1, p2
            return "{}({}{})".format(p1_s, explode(p1_tmp), p2)

        if p2_empty_squig:
            if is_combination(p1):
                # (())(()) + () = (())(()()) => [combined-absorb-right]
                print "> combined-absorb right", p1, p2
                return "{}({}{})".format(p1_s, explode(p1_tmp),p2)
            else:
                # ((())) + () = ((())())  => [absorb-right]
                print "> absorb right", p1, p2
                return "({}{})".format(explode(p1), p2)

        if is_combination(p2):
            if is_squigly_one(p2_tmp):
                # ((())) + (())(()) = ((())(())(())) => [absorb-combined-left]
                print "> absorb-combined-left", p1, p2
                return "({}{})".format(explode(p1), p2)
            else:
                print "> devil wears prada left", p1, p2
                return "({}{}){}".format(p1, explode(p2_tmp), p2_end)

        if not p2_ce and can_explode(p2_tmp):
            print "> absorb-combine-left tmp", p1, p2
            return "({}{}){}".format(p1, explode(p2_tmp), p2_end)

    if can_explode(p2_tmp):
        if p1_is_squig:
            print ">  combine-absorb left", p1, p2
            return "({}{}){}".format(p1, explode(p2_tmp), p2_end)

        if p1_empty_squig:
            if is_combination(p2):
                # () + (())(()) = (()())(()) => [combined-absorb-left]
                print "> combined-absorb left", p1, p2
                return "({}{}){}".format(p1, explode(p2_tmp),p2_end)
            else:
                # () + ((())) = (()(())) => [absorb-left]
                print "> absorb left", p1, p2
                return "({}{})".format(p1, explode(p2))

        if is_combination(p1):
            if is_squigly_one(p1_tmp):
                # (())(())  + ((())) = ( (())(()) (())) => [absorb-combined-right]
                print "> absorb-combined-right", p1, p2
                return "({}{})".format(p1, explode(p2))

            p2_tmp_tmp, p2_tmp_end = get_split(explode(p2_tmp), start=True)
            p1_tmp_s, p1_tmp_tmp = get_split(explode(p1_tmp))
            if is_empty_squigly(p2_tmp_tmp):
                if not is_squigly_combination(p1_tmp_tmp):
                    print "> prince of persia", p1, p2
                    return "{}{}".format(p1,p2)
            # else:
                # print "> prince of persia 2", p1, p2
                # return "{}{}".format(p1,p2)
            # print "> devil wears prada right", p1, p2
            # return "{}({}{})".format(p1_s, explode(p1_tmp), p2)
        # if p1_ce:
            # check that the exploded version of p2 is not a combination
            # if is_combination(explode(p2)):
                # if is_combination(explode(p1_tmp)):
                    # return "{}{}".format(p1,p2)
                # else:
                    # print "> ova chaaa", p1, p2
                    # return "{}({}{})".format(p1_s, explode(p1_tmp), p2)


# > absorb left ()()() (((()())()())())
# > no-fit (()()()((()())()())()) (((()())()())()) True True
# >  combine-absorb right (()()()((()())()())())(((()())()())()) (()())
# > no-fit (()()()((()())()())())(((()())()())()(()())) (()(())) False True
# f: ()()() + (((()())()())()) + (((()())()())()) + (()()) + (()(()))
# a: (()()()((()())()())()) (((()())()())()(()()) (()(())))
# >: (()()()((()())()())()) (((()())()())()(()())) (()(()))

    if can_explode(p1) and can_explode(p2):
        p1_ex = explode(p1)
        p2_ex = explode(p2)
        p1_ex_s, p1_ex_tmp = get_split(p1_ex)
        p2_ex_tmp, p2_ex_end = get_split(p2_ex, start=True)
        # if is_squigly_combination(p1_ex, friendly=True):
            # return "({}{})".format(p1,explode(p2))
        # if is_combination(p1_ex):
        # if is_combination(explode(p1)):
            # if is_squigly_combination(explode(p2_tmp), friendly=True):
                # return "()"
            # else:
            # print "> double-explode-squigly", p1, p2
            # return "({}{}){}".format(p1,explode(p2_tmp), p2_end)

    print "> no-fit", p1, p2, can_explode(p1), can_explode(p2)
    return "{}{}".format(p1,p2)


def solve(p1, p2):
    return deepness_solver(p1,p2)
    return typed_solver(p1,p2)
    return final_solve(p1,p2)
    # global lookup_table
    # if p1 in lookup_table.keys() and p2 in lookup_table[p1].keys():
        # print "> lookup table", p1, p2, lookup_table[p1][p2]
        # return lookup_table[p1][p2]

    # check if we can explode the first one
    p1_ce = can_explode(p1)
    p2_ce = can_explode(p2)
    p1_is_squig = is_squigly_one(p1)
    p2_is_squig = is_squigly_one(p2)
    p1_s, p1_tmp = get_split(p1)
    p2_tmp, p2_end = get_split(p2, start=True)

    if not p1_ce and not p2_ce:
        # none can explode
        # check if we can explode the tmp of
        if can_explode(p1_tmp) and can_explode(p2_tmp):
            return "{}({}{}){}".format(p1_s, explode(p1_tmp), explode(p2_tmp), p2_end)

        if can_explode(p1_tmp):
            return "{}({}{})".format(p1_s,explode(p1_tmp), p2)

        if can_explode(p2_tmp):
            return "({}{}){}".format(p1, explode(p2_tmp), p2_end)

        return "{}{}".format(p1,p2)

    if p1_ce and not p2_ce:
        if is_squigly_one(p2) or is_empty_squigly(p2):
            return "({}{})".format(explode(p1),p2)

        if is_squigly_combination(p1) and is_squigly_combination(p2):
            return "{}{}".format(p1,p2)

        if can_explode(p2_tmp) and is_squigly_one(p1):
            return "({}{}){}".format(p1,explode(p2_tmp),p2_end)

        return "({}{})".format(explode(p1), p2)

    if p2_ce and not p1_ce:
        if is_squigly_one(p1) or is_empty_squigly(p1):
            return "({}{})".format(p1,explode(p2))

        if is_squigly_combination(p1) and is_squigly_combination(p2):
            return "{}{}".format(p1,p2)

        if can_explode(p1_tmp) and is_squigly_one(p2):
            return "{}({}{})".format(p1_s,explode(p1_tmp),p2)

        # ()() + ()() + (()()()(())()()) + (()(((()()())()())()())) + () = ???
        # Solved: (()()()()()()()(())()())(()(((()()())()())()())())
        # Sorry that's not correct.
        #
        # Expected => ( (()()()()()()()(())()()) ()(((()()())()())()())())
        # Actual =>     (()()()()()()()(())()()) ( ()(((()()())()())()()) () )

        # kind of cheating here... vvv just don't get the rule
        if p1_tmp == p2 or flip(p1_tmp[::-1]) == p2:
            return "{}{}".format(p1,p2)

        return "({}{})".format(p1, explode(p2))

    if p1_is_squig and p2_is_squig:
        return "{}{}".format(p1,p2)

    if p1_is_squig:
        return "({}{})".format(p1,explode(p2))

    if p2_is_squig:
        return "({}{})".format(explode(p1),p2)

    # if p1_ce and p2_ce:
        # return "({}{})".format(explode(p1),explode(p2))

    return "{}{}".format(p1,p2)

    p1_start, p1_tmp = get_split(p1)
    p2_tmp, p2_end = get_split(p2, start=True)

    # p1_s = get_split(p1)
    # p2_s = get_split(p2, start=True)
    # p1_tmp = p1[p1_s:]
    # p1_start = p1[:p1_s]
    # p2_tmp = p2[:p2_s]
    # p2_end = p2[p2_s:]

    lp1 = len(p1)
    lp2 = len(p2)

    # DEBUG: Prints for debug
    # print "p1: ", p1, "p2:", p2
    # print "p_s :", p1_s, p2_s
    # print "p_tmp:", p1_tmp, p2_tmp
    # print "p_other", p1_start, p2_end
    # print "solved:", p1_start + combine(p1_tmp, p2_tmp) + p2_end
    # return p1_start + combine(p1_tmp, p2_tmp, lp1, lp2) + p2_end

    # combine
    if p1 == "()" and p2 == "()":
        print "> combine simple"
        return p1 + p2

    if p2 == "()":
        if lp1 != len(p1_tmp):
            print "> combined absorb right"
            # combined-absorb-right
            # (())(()) + () = (()) (()()) => [combined-absorb-right]
            return "{}({}{})".format(p1_start, explode(p1_tmp), p2)
        else:
            print "> absorb right"
            # absorb-right
            return "({}{})".format(explode(p1), p2)

    if p1 == "()":
        if lp2 != len(p2_tmp):
            print "> combined absorb left"
            # combined-absorb-left
            # () + (())(())  = (()())(()) => [combined-absorb-right]
            return "({}{}){}".format(p1, explode(p2_tmp), p2_end)
        else:
            # absorb-left
            print "> absorb left"
            return "({}{})".format(p1, explode(p2))

    if p1_tmp == p1 and p2_tmp == p2:
        t1_s, t1_e = get_split(explode(p1_tmp))
        # (()()) ((()))
        # (()) + (()()())
        if len(t1_e) != len(p1)-2 or (t1_e == '()' and len(t1_e) == len(p1) - 2):
            # can't explode p1
            t2_s, t2_e = get_split(explode(p2_tmp))
            if len(t2_e) != len(p2)-2 or  (t2_e == '()' and len(t2_e) == len(p2) - 2):
                print "> combine equals 1", p1, p2, t2_e
                return "{}{}".format(p1,p2)
            else:
                print "> combine equals 2", p1, p2
                return "({}{})".format(p1,explode(p2))

        t2_s, t2_e = get_split(explode(p2_tmp))
        if len(t2_e) != len(p2)-2 or (t2_e == '()' and len(t2_e) == len(p2) - 2):
            print "> combine equals 3", p1, p2
            # addition of multiple () - can't explode that
            return "({}{})".format(p1,explode(p2))

        print "> combine equals", p1, p2
        return "{}{}".format(p1,p2)

    # absorb combined right
    if lp1 == len(p1_tmp):
        print "> absorb combined right"
        # (())(()) + ( (()) ) = ( (())(()) (()) ) => [absorb-combined-right]
        # print "here:", "({}{})".format(explode(p1), p2)
        return "({}{})".format(explode(p1), p2)

    # absorb combined left
    if lp2 == len(p2_tmp):
        print "> absorb combined left"
        # ((())) + (())(()) = ( (()) (())(()) ) => [absorb-combined-left]
        return "({}{})".format(p1, explode(p2))

    if p1_tmp != p1:
        print "> combine weird 1"
        return "({}{})".format(p1,explode(p2))

    if p2_tmp != p2:
        print "> combine weird 2"
        return "({}{})".format(explode(p1),p2)

    # (()()) + ((())()) = ((()())(())())
    print "> Default case"
    return "({}{})".format(explode(p1), explode(p2))

def recurse(current, q):
    if len(q) < 2:
        return solve(current, q[0])

    return recurse(solve(current, q[0]),q[1:])

def get_q(c):
    resp = c.recvrepeat(0.8)
    print resp
    resp = resp.split('\n')
    q = resp[-3].strip()

    return q

"""
() + () = ()()                                      => [combine]
((())) + () = ((())())                              => [absorb-right]
() + ((())) = (()(()))                              => [absorb-left]
(()) (()) + () = (()) (()())                          => [combined-absorb-right]
() + (())(()) = (()()) (())                          => [combined-absorb-left]
(()) (()) + ((())) = ( (())(()) (()))                  => [absorb-combined-right]
((())) + (())(()) = ((())(())(()))                  => [absorb-combined-left]
() + (()) + ((())) = (()()) + ((())) = ((()())(())) => [left-associative]
"""

data = get_data_from_file()

assert(explode("()") == "")
assert(explode("(())") == "()")
assert(explode("((())())") == "(())()")

assert(can_explode("(()())") == True)
assert(can_explode("(())") == True)
assert(can_explode("()()") == False)
assert(can_explode("()") == False)
assert(can_explode("(())(())") == False)
assert(can_explode("(()(((()()())()())()()))") == True)
assert(can_explode("((())()()())") == True)

assert(is_squigly_one('()()()()') == False)
assert(is_squigly_one('()') == False)
assert(is_squigly_one('(()())') == True)
assert(is_squigly_one('(())') == True)
assert(is_squigly_one('(()()()()())') == True)
assert(is_squigly_one('(()()()()())') == True)
assert(is_squigly_one('((())()())') == False)
assert(is_squigly_one('((())())') == False)

assert(is_squigly_combination("(()(()))") == False)
assert(is_squigly_combination('()()()()()()()(())()()', friendly=True) == True)

assert(is_empty_squigly("()") == True)
assert(is_empty_squigly("()()()") == True)
assert(is_empty_squigly("(()()())") == False)

assert(is_combination("(())(())") == True)

lookup_table = load_table()

failed = 0

assert(solve("()", "()") == "()()") # [combine]
assert(solve("((()))", "()") == "((())())") # [absorb-right]
assert(solve("()", "((()))") == "(()(()))") # [absorb-left]
assert(solve("(())(())", "()") == "(())(()())") # [combined-absorb-right]
assert(solve("()", "(())(())") == "(()())(())") # [combined-absorb-left]
assert(solve("(())(())", "((()))") == "((())(())(()))") # [absorb-combined-right]
assert(solve("((()))", "(())(())") == "((())(())(()))") # [absorb-combined-left]
assert(solve("(()())", "(()())") == "(()())(()())")

for question, answer in lookup_table.items():
    print "Test:", question
    question = question.split('+')
    question = map(string.strip, question)
    result = recurse(question[0],question[1:])
    print "Result:", result
    if result != answer:
        failed += 1
        print "Fail:", " + ".join(question)
        print "Answ:", answer
        print "----:", result
        exit()

print "failed tests: ", failed
assert(failed == 0)

test = map(string.strip, "() + (()) + ((()))".split("+"))
print "q: ", "() + (()) + ((()))", "= ((()())(()))???"
rec = recurse(test[0], test[1:])
print "a: ", rec
assert(recurse(test[0], test[1:]) == "((()())(()))")

test = map(string.strip, "(()) + (()()()) + (()())".split("+"))
print "q: (()) + (()()()) + (()()) = ?"
rec = recurse(test[0], test[1:])
print "a: ", rec
assert(recurse(test[0], test[1:]) == "(())(()()())(()())")


c = connect("2018shell1.picoctf.com", 8672)

while(1):
    q = get_q(c)

    if q in data:
        print "> Found in data"
        c.sendline(data[q])
        continue

    print q
    q = q.split("=")[0].split("+")
    q = map(string.strip, q)


    q = recurse(q[0], q[1:])
    print "Solved:", q
    c.sendline(q)
